# 项目问答笔记

## 一、系统架构与通信

### Q1：Agent启动后，是如何完成注册的？

**你的回答**：
Agent启动时，先检查配置文件里是否配置相关信息，如果检测配置项为空，那就说明没有被注册过，它会拉取配置文件里的server地址，对它进行请求（携带主机的基本信息），服务端返回主机配置信息，填充配置项，并且上报基本数据，后就可以无缝进行上报工作。

**正确理解**：
1. 检查配置文件判断是否已注册
2. 向服务端发送注册请求
3. 服务端返回配置信息
4. 保存到本地配置文件

**关键补充**：
- 健康检查选择最快服务器
- 注册后获得token，后续上报需携带
- 持久化配置到YAML文件

---

### Q2：Agent上报哪两类数据？频率和内容是什么？

**你的回答**：
上报基本数据、运行时数据。基本数据即主机基本信息（操作系统、内存大小、磁盘大小、处理器型号等），运行时数据（内存使用率、磁盘使用率、cpu使用率等）。频率分别为10分钟和15秒。

**数据类型对比**：

| 类型 | 频率 | 内容 |
|------|------|------|
| 基本数据 | 10分钟 | hostname、ip、cpuModel、memoryTotal、diskTotal、gpuModel等 |
| 运行时数据 | 15秒 | cpuUsage、memoryUsage、diskUsage、networkUp、networkDown等 |

**设计原因**：基本数据变化少、数据量大，低频上报减少压力；运行时数据变化快，高频上报保证实时性。

---

### Q3：SSH终端连接流程

#### Q3.1：用户点击"连接SSH"后的数据流转

**你的回答**：
Web点击连接SSH → 服务端验证凭证 → JSCH建立SSH连接 → 生成SESSION ID → 前端用SESSION ID建立WS连接 → 双向转发数据

**完整流程**：
1. 前端调用 `POST /api/v1/ssh/connect`，携带agentId和凭证
2. Server使用JSch连接目标主机SSH（22端口）
3. 创建SshSession对象，生成sessionId
4. 前端用sessionId建立WebSocket连接
5. Server将WS输入流转发到SSH，SSH输出流转发到WS

#### Q3.2：为什么需要WebSocket？

**你的回答**：
HTTP单向通信，WS支持双向通信

**对比**：
- HTTP：请求-响应模式，服务器无法主动推送
- WebSocket：全双工通信，持续传输SSH输出流

#### Q3.3：Server端如何管理多个SSH会话？

**你的回答**：
创建 → 用户连接 → 保持活跃 → 用户关闭 → 清理

**技术实现**：
使用`ConcurrentHashMap<String, SshSession> activeSessions`，sessionId作为key管理多个会话。

---

## 二、认证与授权

### Q4：用户授权机制

#### Q4.1：用户登录后如何获得Token？存储在哪里？

**你的回答**：
用户请求登录 → 后端验证 → 返回Token → 存储在Pinia

**补充**：
同时存储到localStorage，刷新页面后保持登录状态

#### Q4.2：后续请求如何验证Token？

**你的回答**：
使用密钥解密，验证签名是否被篡改，是否过期

**正确理解**：
- 请求头携带：`Authorization: Bearer <token>`
- JwtAuthenticationFilter拦截请求
- JwtTokenProvider验证签名和过期时间
- 无需查数据库密码（JWT无状态设计）

---

## 三、模块依赖

### Q5：项目模块依赖

#### Q5.1：CommonLibrary模块的作用是什么？

**回答**：
维护Agent和Server共用的请求/响应实体类，避免代码重复。

**包含内容**：
- model：BasicInfo、Metrics
- request：RegisterRequest、BasicReportRequest、MetricsReportRequest
- response：BaseResponse、RegisterResponse

#### Q5.2：Monitor-Server为什么依赖Monitor-Agent？

**回答**：
Server需要使用Agent的AgentConfig配置类，用于解析和生成Agent配置文件。

---

## 四、数据存储

### Q6：数据库设计

#### Q6.1：有哪些核心表？

**你的回答**：
MySQL，4张表：用户表、主机表、凭证表、运行时数据表

**详细说明**：

| 表名 | 作用 | 关键字段 |
|------|------|----------|
| user | 用户账号信息 | id, username, email, password |
| agent | 主机基本信息 | agent_id, hostname, ip, cpu_model, memory_total |
| ssh_credential | SSH连接凭证 | agent_id, username, password |
| agent_metrics | 运行时监控数据 | agent_id, cpu_usage, memory_usage, timestamp |

#### Q6.2：监控数据存储在哪里？

**你的回答**：
MySQL

**补充**：
项目已引入InfluxDB依赖但未使用，未来可考虑迁移到InfluxDB优化时序数据存储性能。

---

## 五、功能实现

### Q7：邮件验证功能是如何实现的？

**完整流程**：
1. 用户点击"发送验证码"，前端调用`POST /api/auth/send-code`
2. AuthController创建消息（包含邮箱地址），发送到RabbitMQ队列
3. MailQueueListener监听队列，消费消息
4. 生成6位随机验证码，存入Redis（key: `email:code:{email}`，5分钟过期）
5. 使用JavaMailSender发送HTML格式邮件到用户邮箱
6. 用户输入验证码，服务端从Redis取值比对

**为什么用RabbitMQ**：邮件发送是耗时操作，异步处理提高响应速度。

---

### Q8：Agent为什么配置多个Server地址？

**你的回答**：
选择最快的服务器连接，目前开发阶段还没有多服务端部署

**应用场景**：
- 负载均衡：Agent自动选择响应最快的服务器
- 高可用：主服务器宕机时自动切换到备用服务器
- 水平扩展：新增服务器只需在配置文件添加地址

---

## 六、项目优化方向

### Q9：待优化点

**功能层面**：
1. AI助手：后端接口缺失，前端UI不完整
2. 用户管理：前端有页面，但后端缺少CRUD接口
3. SSH凭证加密：当前明文存储在数据库
4. InfluxDB集成：依赖已引入但未使用

**技术层面**：
5. WebSocket优化：可改用@ServerEndpoint注解方式
6. 心跳机制：WebSocket连接缺少心跳保活
7. 终端二进制消息：resize等二进制消息未支持

**架构层面**：
8. 离线检测：依赖超时判断，可增加主动心跳机制
9. 配置热更新：Agent配置修改后需要重启

---

### Q10：项目价值

**当前已实现的核心价值**：

1. **Web SSH代理**：通过WebSocket在浏览器和目标主机SSH之间建立双向转发通道，实现浏览器直接操作远程终端，跨平台运维。

2. **轻量级监控**：Agent双频上报机制（10分钟基本数据、15秒运行时数据），平衡实时性和系统负载。

**未来价值（AI智能运维）**：
- Agent主动分析日志异常，上报告警
- 服务端下发运维指令，Agent执行并返回结果
- AI理解自然语言，自动生成Shell命令并执行

---

### Q11：父POM的作用

**你的回答**：
管理项目组织形式、管理依赖、方便更换和增添模块

**具体价值**：
1. **版本统一管理**：所有第三方库版本在父POM定义，升级只需修改一处
2. **避免依赖冲突**：Spring Cloud通过BOM管理，确保版本兼容
3. **构建统一**：从父目录执行`mvn clean compile`可一次编译所有模块
4. **配置继承**：统一Java版本、编译器配置、编码格式
